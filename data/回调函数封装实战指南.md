# 回调函数封装实战指南

## 🎯 如何识别回调封装机会

### 🔍 识别信号（Code Smells）

当你在代码中发现以下情况时，就是封装回调的好时机：

#### 1. **重复的模板代码**
```java
// ❌ 重复的异常处理模板
public void saveUser(User user) {
    try {
        // 业务逻辑
        userRepository.save(user);
        log.info("用户保存成功: {}", user.getName());
    } catch (Exception e) {
        log.error("用户保存失败: {}", e.getMessage());
        throw new BusinessException("保存失败");
    }
}

public void saveOrder(Order order) {
    try {
        // 业务逻辑
        orderRepository.save(order);
        log.info("订单保存成功: {}", order.getId());
    } catch (Exception e) {
        log.error("订单保存失败: {}", e.getMessage());
        throw new BusinessException("保存失败");
    }
}

// ✅ 使用回调封装
public class SafeExecutor {
    public static <T> T execute(String operation, Supplier<T> action) {
        try {
            T result = action.get();
            log.info("{}成功", operation);
            return result;
        } catch (Exception e) {
            log.error("{}失败: {}", operation, e.getMessage());
            throw new BusinessException(operation + "失败");
        }
    }
}

// 使用
SafeExecutor.execute("用户保存", () -> userRepository.save(user));
SafeExecutor.execute("订单保存", () -> orderRepository.save(order));
```

#### 2. **条件分支过多**
```java
// ❌ 复杂的条件处理
public void processData(String type, Object data) {
    if ("user".equals(type)) {
        // 用户处理逻辑
        validateUser((User) data);
        saveUser((User) data);
        sendUserNotification((User) data);
    } else if ("order".equals(type)) {
        // 订单处理逻辑
        validateOrder((Order) data);
        saveOrder((Order) data);
        sendOrderNotification((Order) data);
    } else if ("product".equals(type)) {
        // 产品处理逻辑
        validateProduct((Product) data);
        saveProduct((Product) data);
        updateInventory((Product) data);
    }
}

// ✅ 使用回调策略
public class DataProcessor {
    private Map<String, Consumer<Object>> processors = new HashMap<>();
    
    public DataProcessor() {
        processors.put("user", data -> processUser((User) data));
        processors.put("order", data -> processOrder((Order) data));
        processors.put("product", data -> processProduct((Product) data));
    }
    
    public void process(String type, Object data) {
        Consumer<Object> processor = processors.get(type);
        if (processor != null) {
            processor.accept(data);
        } else {
            throw new IllegalArgumentException("未知类型: " + type);
        }
    }
    
    private void processUser(User user) {
        validateUser(user);
        saveUser(user);
        sendUserNotification(user);
    }
}
```

#### 3. **固定流程，可变步骤**
```java
// ❌ 硬编码的处理流程
public void processPayment(PaymentRequest request) {
    // 1. 验证
    validatePayment(request);
    
    // 2. 处理 - 不同支付方式处理逻辑不同
    if (request.getType() == PaymentType.ALIPAY) {
        // 支付宝处理逻辑
        callAlipayAPI(request);
    } else if (request.getType() == PaymentType.WECHAT) {
        // 微信处理逻辑
        callWechatAPI(request);
    }
    
    // 3. 记录
    logPayment(request);
    
    // 4. 通知
    sendNotification(request);
}

// ✅ 使用回调模板
public class PaymentProcessor {
    public void processPayment(PaymentRequest request, 
                             Consumer<PaymentRequest> paymentHandler) {
        // 固定流程
        validatePayment(request);
        
        // 可变步骤 - 通过回调处理
        paymentHandler.accept(request);
        
        // 固定流程
        logPayment(request);
        sendNotification(request);
    }
}

// 使用
processor.processPayment(request, req -> callAlipayAPI(req));
processor.processPayment(request, req -> callWechatAPI(req));
```

## 🎪 常见封装场景

### 1. **资源管理场景**

#### 数据库连接管理
```java
public class DatabaseTemplate {
    /**
     * 执行数据库操作，自动管理连接
     * @param operation 数据库操作回调
     * @return 操作结果
     */
    public <T> T execute(Function<Connection, T> operation) {
        Connection conn = null;
        try {
            conn = dataSource.getConnection();
            conn.setAutoCommit(false);
            
            T result = operation.apply(conn);
            
            conn.commit();
            return result;
        } catch (Exception e) {
            if (conn != null) {
                try {
                    conn.rollback();
                } catch (SQLException ex) {
                    log.error("回滚失败", ex);
                }
            }
            throw new RuntimeException("数据库操作失败", e);
        } finally {
            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException e) {
                    log.error("关闭连接失败", e);
                }
            }
        }
    }
}

// 使用
Integer userId = dbTemplate.execute(conn -> {
    PreparedStatement ps = conn.prepareStatement(
        "INSERT INTO users (name, email) VALUES (?, ?)", 
        Statement.RETURN_GENERATED_KEYS);
    ps.setString(1, user.getName());
    ps.setString(2, user.getEmail());
    ps.executeUpdate();
    
    ResultSet rs = ps.getGeneratedKeys();
    return rs.next() ? rs.getInt(1) : null;
});
```

#### 文件操作管理
```java
public class FileTemplate {
    /**
     * 安全的文件操作，自动关闭资源
     * @param filePath 文件路径
     * @param operation 文件操作回调
     */
    public <T> T withFile(String filePath, Function<BufferedReader, T> operation) {
        try (BufferedReader reader = Files.newBufferedReader(Paths.get(filePath))) {
            return operation.apply(reader);
        } catch (IOException e) {
            throw new RuntimeException("文件操作失败: " + filePath, e);
        }
    }
    
    /**
     * 安全的文件写入操作
     * @param filePath 文件路径
     * @param writer 写入操作回调
     */
    public void writeFile(String filePath, Consumer<BufferedWriter> writer) {
        try (BufferedWriter bw = Files.newBufferedWriter(Paths.get(filePath))) {
            writer.accept(bw);
        } catch (IOException e) {
            throw new RuntimeException("文件写入失败: " + filePath, e);
        }
    }
}

// 使用
List<String> lines = fileTemplate.withFile("data.txt", reader -> {
    return reader.lines().collect(Collectors.toList());
});

fileTemplate.writeFile("output.txt", writer -> {
    writer.write("Hello World");
    writer.newLine();
    writer.write("From Callback");
});
```

### 2. **性能监控场景**

#### 执行时间监控
```java
public class PerformanceMonitor {
    /**
     * 监控方法执行时间
     * @param methodName 方法名称
     * @param operation 要监控的操作
     * @return 操作结果
     */
    public <T> T monitor(String methodName, Supplier<T> operation) {
        long startTime = System.currentTimeMillis();
        try {
            T result = operation.get();
            long duration = System.currentTimeMillis() - startTime;
            log.info("方法 {} 执行耗时: {}ms", methodName, duration);
            
            // 性能告警
            if (duration > 1000) {
                log.warn("方法 {} 执行时间过长: {}ms", methodName, duration);
            }
            
            return result;
        } catch (Exception e) {
            long duration = System.currentTimeMillis() - startTime;
            log.error("方法 {} 执行失败，耗时: {}ms", methodName, duration, e);
            throw e;
        }
    }
    
    /**
     * 无返回值方法监控
     * @param methodName 方法名称
     * @param operation 要监控的操作
     */
    public void monitor(String methodName, Runnable operation) {
        monitor(methodName, () -> {
            operation.run();
            return null;
        });
    }
}

// 使用
List<User> users = monitor.monitor("查询用户列表", () -> {
    return userService.findAll();
});

monitor.monitor("发送邮件", () -> {
    emailService.sendWelcomeEmail(user);
});
```

### 3. **缓存场景**

#### 缓存模板
```java
public class CacheTemplate {
    private final RedisTemplate<String, Object> redisTemplate;
    
    /**
     * 缓存获取模板，如果缓存不存在则执行回调并缓存结果
     * @param key 缓存键
     * @param supplier 数据获取回调
     * @param expireSeconds 过期时间（秒）
     * @return 缓存或新获取的数据
     */
    @SuppressWarnings("unchecked")
    public <T> T getOrSet(String key, Supplier<T> supplier, long expireSeconds) {
        // 尝试从缓存获取
        T cached = (T) redisTemplate.opsForValue().get(key);
        if (cached != null) {
            log.debug("缓存命中: {}", key);
            return cached;
        }
        
        // 缓存未命中，执行回调获取数据
        log.debug("缓存未命中，执行回调: {}", key);
        T result = supplier.get();
        
        // 缓存结果
        if (result != null) {
            redisTemplate.opsForValue().set(key, result, expireSeconds, TimeUnit.SECONDS);
            log.debug("数据已缓存: {}", key);
        }
        
        return result;
    }
    
    /**
     * 分布式锁执行模板
     * @param lockKey 锁键
     * @param operation 需要加锁执行的操作
     * @param timeoutSeconds 锁超时时间
     */
    public <T> T withLock(String lockKey, Supplier<T> operation, long timeoutSeconds) {
        String lockValue = UUID.randomUUID().toString();
        boolean locked = false;
        
        try {
            // 尝试获取锁
            locked = redisTemplate.opsForValue()
                .setIfAbsent(lockKey, lockValue, timeoutSeconds, TimeUnit.SECONDS);
            
            if (!locked) {
                throw new RuntimeException("获取锁失败: " + lockKey);
            }
            
            // 执行业务操作
            return operation.get();
            
        } finally {
            // 释放锁
            if (locked) {
                String script = "if redis.call('get', KEYS[1]) == ARGV[1] then " +
                              "return redis.call('del', KEYS[1]) else return 0 end";
                redisTemplate.execute(new DefaultRedisScript<>(script, Long.class), 
                                    Collections.singletonList(lockKey), lockValue);
            }
        }
    }
}

// 使用
User user = cacheTemplate.getOrSet(
    "user:" + userId, 
    () -> userService.findById(userId), 
    3600  // 1小时过期
);

String result = cacheTemplate.withLock(
    "order:process:" + orderId,
    () -> orderService.processOrder(orderId),
    30  // 30秒超时
);
```

### 4. **验证场景**

#### 参数验证模板
```java
public class ValidationTemplate {
    /**
     * 执行验证并处理业务逻辑
     * @param data 要验证的数据
     * @param validators 验证器列表
     * @param operation 验证通过后的业务操作
     */
    public <T, R> R validateAndExecute(T data, 
                                      List<Consumer<T>> validators,
                                      Function<T, R> operation) {
        // 执行所有验证
        for (Consumer<T> validator : validators) {
            validator.accept(data);
        }
        
        // 验证通过，执行业务逻辑
        return operation.apply(data);
    }
    
    /**
     * 创建验证器
     */
    public static <T> Consumer<T> notNull(Function<T, Object> getter, String fieldName) {
        return data -> {
            if (getter.apply(data) == null) {
                throw new IllegalArgumentException(fieldName + "不能为空");
            }
        };
    }
    
    public static Consumer<String> notBlank(String fieldName) {
        return value -> {
            if (value == null || value.trim().isEmpty()) {
                throw new IllegalArgumentException(fieldName + "不能为空");
            }
        };
    }
    
    public static <T extends Number> Consumer<T> range(T min, T max, String fieldName) {
        return value -> {
            if (value.doubleValue() < min.doubleValue() || 
                value.doubleValue() > max.doubleValue()) {
                throw new IllegalArgumentException(
                    fieldName + "必须在" + min + "和" + max + "之间");
            }
        };
    }
}

// 使用
User savedUser = validationTemplate.validateAndExecute(
    user,
    Arrays.asList(
        ValidationTemplate.notNull(User::getName, "用户名"),
        ValidationTemplate.notNull(User::getEmail, "邮箱"),
        data -> ValidationTemplate.notBlank("用户名").accept(data.getName()),
        data -> ValidationTemplate.range(18, 100, "年龄").accept(data.getAge())
    ),
    validUser -> userService.save(validUser)
);
```

### 5. **重试场景**

#### 重试模板
```java
public class RetryTemplate {
    /**
     * 带重试的操作执行
     * @param operation 要执行的操作
     * @param maxRetries 最大重试次数
     * @param delayMs 重试间隔（毫秒）
     * @param retryCondition 重试条件判断
     */
    public <T> T executeWithRetry(Supplier<T> operation, 
                                 int maxRetries, 
                                 long delayMs,
                                 Predicate<Exception> retryCondition) {
        Exception lastException = null;
        
        for (int attempt = 0; attempt <= maxRetries; attempt++) {
            try {
                return operation.get();
            } catch (Exception e) {
                lastException = e;
                
                // 检查是否应该重试
                if (attempt == maxRetries || !retryCondition.test(e)) {
                    break;
                }
                
                log.warn("操作失败，第{}次重试，{}ms后重试: {}", 
                        attempt + 1, delayMs, e.getMessage());
                
                // 等待后重试
                try {
                    Thread.sleep(delayMs);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException("重试被中断", ie);
                }
            }
        }
        
        throw new RuntimeException("操作失败，已达到最大重试次数: " + maxRetries, lastException);
    }
    
    /**
     * 简化版重试（默认重试条件）
     */
    public <T> T executeWithRetry(Supplier<T> operation, int maxRetries, long delayMs) {
        return executeWithRetry(operation, maxRetries, delayMs, e -> {
            // 默认重试条件：网络异常、超时异常
            return e instanceof IOException || 
                   e instanceof TimeoutException ||
                   e.getCause() instanceof SocketTimeoutException;
        });
    }
}

// 使用
String response = retryTemplate.executeWithRetry(
    () -> httpClient.get("https://api.example.com/data"),
    3,    // 最多重试3次
    1000  // 每次间隔1秒
);

User user = retryTemplate.executeWithRetry(
    () -> userService.findById(userId),
    2,
    500,
    e -> e instanceof DataAccessException  // 只有数据访问异常才重试
);
```

## 🎯 识别方法总结

### 🔍 问自己这些问题

1. **是否有重复代码？**
   - 相同的try-catch模板
   - 相似的验证逻辑
   - 重复的资源管理代码

2. **是否有固定流程？**
   - 前置处理 → 核心逻辑 → 后置处理
   - 获取资源 → 使用资源 → 释放资源
   - 验证 → 执行 → 记录

3. **是否需要策略切换？**
   - 不同的处理方式
   - 可配置的行为
   - 运行时决定的逻辑

4. **是否需要横切关注点？**
   - 日志记录
   - 性能监控
   - 异常处理
   - 事务管理

### 🎪 封装的好处

1. **减少重复代码**：DRY原则
2. **提高可读性**：业务逻辑更清晰
3. **便于测试**：逻辑分离，易于单元测试
4. **增强复用性**：一次封装，多处使用
5. **降低出错率**：统一处理，减少遗漏

### 🚀 实践建议

1. **从小处开始**：先封装简单的重复逻辑
2. **逐步抽象**：发现模式后再进行抽象
3. **保持简单**：不要过度设计
4. **文档完善**：清楚说明使用方法和注意事项
5. **单元测试**：确保封装的正确性

---

## 📝 实战检查清单

当你写代码时，经常问自己：

- [ ] 这段代码我之前写过类似的吗？
- [ ] 这个方法是否包含了多个职责？
- [ ] 这里的异常处理能否统一？
- [ ] 这个资源管理逻辑能否复用？
- [ ] 这个验证逻辑其他地方也需要吗？
- [ ] 这个性能监控能否自动化？

如果答案是"是"，那就是封装回调的好时机！

---

*记住：好的封装来自于对重复模式的敏锐观察和持续重构的习惯。*