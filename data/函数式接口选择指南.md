# 函数式接口选择指南

## 🎯 核心函数式接口概览

### 📋 接口对比表

| 接口名称 | 方法签名 | 用途 | 输入 | 输出 | 典型场景 |
|---------|---------|------|------|------|----------|
| `Supplier<T>` | `T get()` | 供应商 | 无 | 有 | 数据获取、懒加载 |
| `Consumer<T>` | `void accept(T t)` | 消费者 | 有 | 无 | 数据处理、副作用操作 |
| `Function<T,R>` | `R apply(T t)` | 函数 | 有 | 有 | 数据转换、映射 |
| `Predicate<T>` | `boolean test(T t)` | 断言 | 有 | boolean | 条件判断、过滤 |
| `Runnable` | `void run()` | 执行器 | 无 | 无 | 简单任务执行 |

## 🔍 详细选择指南

### 1. Supplier<T> - 数据供应商

**何时使用：**
- 需要延迟获取数据
- 数据获取可能失败需要重试
- 缓存未命中时的数据加载
- 工厂方法模式

```java
// ✅ 适合使用 Supplier 的场景

// 1. 缓存获取
public <T> T getFromCache(String key, Supplier<T> dataLoader) {
    T cached = cache.get(key);
    if (cached != null) {
        return cached;
    }
    
    // 缓存未命中，使用 Supplier 获取数据
    T data = dataLoader.get();
    cache.put(key, data);
    return data;
}

// 使用
User user = getFromCache("user:123", () -> {
    // 复杂的数据库查询
    return userRepository.findByIdWithDetails(123L);
});

// 2. 懒加载配置
public class ConfigManager {
    private final Supplier<Properties> configLoader;
    private Properties config;
    
    public ConfigManager(Supplier<Properties> configLoader) {
        this.configLoader = configLoader;
    }
    
    public String getProperty(String key) {
        if (config == null) {
            config = configLoader.get();  // 延迟加载
        }
        return config.getProperty(key);
    }
}

// 使用
ConfigManager manager = new ConfigManager(() -> {
    // 只有在真正需要时才加载配置文件
    return loadConfigFromFile("application.properties");
});

// 3. 重试机制
public <T> T executeWithRetry(Supplier<T> operation, int maxRetries) {
    for (int i = 0; i < maxRetries; i++) {
        try {
            return operation.get();  // 每次重试都调用 Supplier
        } catch (Exception e) {
            if (i == maxRetries - 1) throw e;
            // 等待后重试
            sleep(1000);
        }
    }
    throw new RuntimeException("重试失败");
}

// 使用
String result = executeWithRetry(() -> {
    return httpClient.get("https://api.example.com/data");
}, 3);
```

### 2. Consumer<T> - 数据消费者

**何时使用：**
- 对数据进行处理但不需要返回值
- 执行副作用操作（日志、通知、更新状态）
- 构建器模式中的配置回调
- 事件处理

```java
// ✅ 适合使用 Consumer 的场景

// 1. 数据处理管道
public class DataProcessor {
    public void processUsers(List<User> users, Consumer<User> processor) {
        for (User user : users) {
            try {
                processor.accept(user);  // 处理每个用户
            } catch (Exception e) {
                log.error("处理用户失败: {}", user.getId(), e);
            }
        }
    }
}

// 使用
processor.processUsers(userList, user -> {
    // 发送欢迎邮件
    emailService.sendWelcomeEmail(user);
    // 更新用户状态
    user.setStatus(UserStatus.ACTIVE);
    userRepository.save(user);
});

// 2. 构建器配置
public class EmailBuilder {
    public EmailBuilder withRecipients(Consumer<List<String>> recipientConfig) {
        List<String> recipients = new ArrayList<>();
        recipientConfig.accept(recipients);  // 让用户配置收件人列表
        this.recipients = recipients;
        return this;
    }
}

// 使用
Email email = EmailBuilder.create()
    .withSubject("通知")
    .withRecipients(recipients -> {
        recipients.add("admin@example.com");
        recipients.add("user@example.com");
        if (isUrgent) {
            recipients.add("manager@example.com");
        }
    })
    .build();

// 3. 事件监听
public class EventBus {
    private Map<Class<?>, List<Consumer<Object>>> listeners = new HashMap<>();
    
    public <T> void subscribe(Class<T> eventType, Consumer<T> listener) {
        listeners.computeIfAbsent(eventType, k -> new ArrayList<>())
                .add((Consumer<Object>) listener);
    }
    
    public void publish(Object event) {
        List<Consumer<Object>> eventListeners = listeners.get(event.getClass());
        if (eventListeners != null) {
            eventListeners.forEach(listener -> listener.accept(event));
        }
    }
}

// 使用
eventBus.subscribe(UserRegisteredEvent.class, event -> {
    log.info("用户注册: {}", event.getUserId());
    // 发送欢迎邮件
    emailService.sendWelcomeEmail(event.getUser());
});
```

### 3. Function<T,R> - 数据转换器

**何时使用：**
- 数据类型转换
- 业务逻辑计算
- 映射操作
- 需要输入和输出的场景

```java
// ✅ 适合使用 Function 的场景

// 1. 数据转换管道
public class DataTransformer {
    public <T, R> List<R> transform(List<T> input, Function<T, R> transformer) {
        return input.stream()
                   .map(transformer)
                   .collect(Collectors.toList());
    }
    
    public <T, R> R transformSingle(T input, Function<T, R> transformer) {
        if (input == null) {
            return null;
        }
        return transformer.apply(input);
    }
}

// 使用
List<UserDTO> userDTOs = transformer.transform(users, user -> {
    UserDTO dto = new UserDTO();
    dto.setId(user.getId());
    dto.setName(user.getName());
    dto.setEmail(user.getEmail());
    dto.setAge(calculateAge(user.getBirthDate()));
    return dto;
});

// 2. 缓存计算结果
public class ComputeCache {
    private final Map<String, Object> cache = new ConcurrentHashMap<>();
    
    @SuppressWarnings("unchecked")
    public <T, R> R computeIfAbsent(String key, T input, Function<T, R> computer) {
        return (R) cache.computeIfAbsent(key, k -> computer.apply(input));
    }
}

// 使用
BigDecimal result = computeCache.computeIfAbsent(
    "tax:" + orderId,
    order,
    ord -> {
        // 复杂的税费计算
        return calculateTax(ord.getAmount(), ord.getRegion());
    }
);

// 3. 条件转换
public class ConditionalTransformer {
    public <T, R> R transformIf(T input, 
                               Predicate<T> condition,
                               Function<T, R> transformer,
                               R defaultValue) {
        if (condition.test(input)) {
            return transformer.apply(input);
        }
        return defaultValue;
    }
}

// 使用
String displayName = conditionalTransformer.transformIf(
    user,
    u -> u.getName() != null && !u.getName().trim().isEmpty(),
    u -> u.getName().toUpperCase(),
    "匿名用户"
);
```

### 4. Predicate<T> - 条件判断器

**何时使用：**
- 数据过滤
- 条件验证
- 业务规则判断
- 权限检查

```java
// ✅ 适合使用 Predicate 的场景

// 1. 数据过滤器
public class DataFilter {
    public <T> List<T> filter(List<T> data, Predicate<T> condition) {
        return data.stream()
                  .filter(condition)
                  .collect(Collectors.toList());
    }
    
    public <T> boolean anyMatch(List<T> data, Predicate<T> condition) {
        return data.stream().anyMatch(condition);
    }
    
    public <T> boolean allMatch(List<T> data, Predicate<T> condition) {
        return data.stream().allMatch(condition);
    }
}

// 使用
List<User> activeUsers = dataFilter.filter(users, user -> {
    return user.getStatus() == UserStatus.ACTIVE && 
           user.getLastLoginTime().isAfter(LocalDateTime.now().minusDays(30));
});

// 2. 业务规则验证
public class BusinessRuleValidator {
    public <T> ValidationResult validate(T data, List<Predicate<T>> rules) {
        for (int i = 0; i < rules.size(); i++) {
            if (!rules.get(i).test(data)) {
                return ValidationResult.fail("规则 " + (i + 1) + " 验证失败");
            }
        }
        return ValidationResult.success();
    }
}

// 使用
ValidationResult result = validator.validate(order, Arrays.asList(
    ord -> ord.getAmount().compareTo(BigDecimal.ZERO) > 0,  // 金额大于0
    ord -> ord.getCustomerId() != null,                     // 客户ID不为空
    ord -> ord.getItems().size() > 0,                       // 至少有一个商品
    ord -> ord.getItems().stream().allMatch(item -> item.getQuantity() > 0)  // 商品数量大于0
));

// 3. 权限检查
public class PermissionChecker {
    public <T> boolean hasPermission(T resource, User user, Predicate<T> permissionRule) {
        return permissionRule.test(resource);
    }
}

// 使用
boolean canEdit = permissionChecker.hasPermission(document, currentUser, doc -> {
    return doc.getOwnerId().equals(currentUser.getId()) || 
           currentUser.hasRole("ADMIN") ||
           doc.getCollaborators().contains(currentUser.getId());
});
```

### 5. Runnable - 简单任务执行器

**何时使用：**
- 无参数无返回值的简单任务
- 异步执行
- 定时任务
- 清理操作

```java
// ✅ 适合使用 Runnable 的场景

// 1. 异步任务执行
public class AsyncExecutor {
    private final ExecutorService executor = Executors.newFixedThreadPool(10);
    
    public void executeAsync(Runnable task) {
        executor.submit(task);
    }
    
    public void executeWithDelay(Runnable task, long delaySeconds) {
        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
        scheduler.schedule(task, delaySeconds, TimeUnit.SECONDS);
    }
}

// 使用
asyncExecutor.executeAsync(() -> {
    // 发送邮件通知
    emailService.sendNotification("订单已创建", order);
});

asyncExecutor.executeWithDelay(() -> {
    // 5分钟后检查订单状态
    checkOrderStatus(orderId);
}, 300);

// 2. 资源清理
public class ResourceManager {
    public void withResource(Supplier<AutoCloseable> resourceSupplier, 
                           Consumer<AutoCloseable> resourceUser,
                           Runnable cleanup) {
        AutoCloseable resource = null;
        try {
            resource = resourceSupplier.get();
            resourceUser.accept(resource);
        } catch (Exception e) {
            log.error("资源使用失败", e);
        } finally {
            if (resource != null) {
                try {
                    resource.close();
                } catch (Exception e) {
                    log.error("资源关闭失败", e);
                }
            }
            // 额外的清理工作
            cleanup.run();
        }
    }
}

// 使用
resourceManager.withResource(
    () -> dataSource.getConnection(),
    conn -> {
        // 使用数据库连接
        executeQuery(conn, sql);
    },
    () -> {
        // 清理临时文件
        cleanupTempFiles();
        // 清理缓存
        clearCache();
    }
);
```

## 🎯 组合使用场景

### 多接口组合

```java
// 复杂的数据处理管道
public class DataPipeline<T> {
    public <R> DataPipeline<R> filter(Predicate<T> condition) {
        // 过滤数据
        return new DataPipeline<>(data.stream().filter(condition).collect(Collectors.toList()));
    }
    
    public <R> DataPipeline<R> map(Function<T, R> mapper) {
        // 转换数据
        return new DataPipeline<>(data.stream().map(mapper).collect(Collectors.toList()));
    }
    
    public void forEach(Consumer<T> action) {
        // 处理每个元素
        data.forEach(action);
    }
    
    public T findFirst(Predicate<T> condition, Supplier<T> defaultSupplier) {
        // 查找第一个匹配的元素，如果没有则使用默认值
        return data.stream()
                  .filter(condition)
                  .findFirst()
                  .orElseGet(defaultSupplier);
    }
}

// 使用
new DataPipeline<>(users)
    .filter(user -> user.getAge() >= 18)           // Predicate
    .map(user -> user.getEmail())                  // Function
    .forEach(email -> sendEmail(email));           // Consumer

User defaultUser = new DataPipeline<>(users)
    .findFirst(
        user -> user.getRole() == Role.ADMIN,      // Predicate
        () -> createDefaultAdmin()                 // Supplier
    );
```

## 📋 选择决策树

```
需要回调函数？
├─ 无输入参数？
│  ├─ 有返回值？ → Supplier<T>
│  └─ 无返回值？ → Runnable
└─ 有输入参数？
   ├─ 无返回值？ → Consumer<T>
   ├─ 返回boolean？ → Predicate<T>
   └─ 返回其他类型？ → Function<T,R>
```

## 🎪 实际项目中的选择建议

### 1. **构建器模式**
```java
// 配置类属性 → Consumer
builder.configureDatabase(db -> {
    db.setUrl("jdbc:postgresql://localhost:5432/mydb");
    db.setUsername("user");
});

// 条件配置 → Predicate + Consumer
builder.configureIf(
    env -> "production".equals(env.getProfile()),  // Predicate
    config -> config.enableSsl(true)              // Consumer
);
```

### 2. **缓存模式**
```java
// 数据获取 → Supplier
cacheManager.getOrCompute(key, () -> expensiveOperation());

// 数据转换 → Function
cacheManager.getOrTransform(key, data -> transformData(data));
```

### 3. **验证模式**
```java
// 条件验证 → Predicate
validator.validate(data, d -> d.getAge() >= 18);

// 复杂验证 → Function
validator.validateAndTransform(data, d -> {
    if (d.isValid()) {
        return ValidationResult.success(d);
    }
    return ValidationResult.error("验证失败");
});
```

### 4. **事件处理**
```java
// 事件监听 → Consumer
eventBus.on(UserCreatedEvent.class, event -> handleUserCreated(event));

// 条件事件处理 → Predicate + Consumer
eventBus.onIf(
    event -> event.getUser().isVip(),     // Predicate
    event -> sendVipWelcomeEmail(event)   // Consumer
);
```

## 💡 最佳实践

### ✅ 推荐做法

1. **明确语义**：选择最能表达意图的接口
2. **保持简单**：避免在Lambda中写过于复杂的逻辑
3. **异常处理**：在框架层统一处理异常
4. **类型安全**：充分利用泛型确保类型安全

### ❌ 避免的做法

1. **滥用Function**：不要把所有回调都用Function
2. **忽略语义**：不要仅仅因为签名匹配就选择接口
3. **过度嵌套**：避免Lambda中再嵌套Lambda
4. **副作用混乱**：Function应该是纯函数，避免副作用

---

## 📝 快速参考

| 场景 | 推荐接口 | 示例 |
|------|----------|------|
| 懒加载数据 | `Supplier<T>` | `() -> loadFromDatabase()` |
| 处理数据 | `Consumer<T>` | `user -> sendEmail(user)` |
| 转换数据 | `Function<T,R>` | `user -> user.getName()` |
| 过滤条件 | `Predicate<T>` | `user -> user.isActive()` |
| 简单任务 | `Runnable` | `() -> cleanup()` |
| 构建器配置 | `Consumer<T>` | `builder -> builder.setName("test")` |
| 缓存获取 | `Supplier<T>` | `() -> computeExpensiveValue()` |
| 条件执行 | `Predicate<T>` | `order -> order.getAmount() > 100` |

记住：**选择最能表达你意图的接口，让代码自文档化！**