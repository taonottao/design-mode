# 建造者模式应用场景识别指南

## 🎯 什么是建造者模式？

建造者模式（Builder Pattern）是一种创建型设计模式，它允许你分步骤创建复杂对象。该模式将对象的构造过程与其表示分离，使得同样的构造过程可以创建不同的表示。

## 🔍 何时应该使用建造者模式？

### 1. 📋 核心判断标准

#### ✅ 强烈推荐使用的场景

**参数数量多（≥4个参数）**
```java
// ❌ 构造函数参数过多，难以理解和使用
public class User {
    public User(String name, String email, String phone, 
                Integer age, String address, String company, 
                String department, String position) {
        // ...
    }
}

// ✅ 使用建造者模式
User user = User.builder()
    .name("张三")
    .email("zhangsan@example.com")
    .phone("13800138000")
    .age(25)
    .address("北京市朝阳区")
    .company("科技公司")
    .department("研发部")
    .position("Java工程师")
    .build();
```

**可选参数多**
```java
// ❌ 需要多个重载构造函数
public class DatabaseConfig {
    public DatabaseConfig(String url, String username, String password) {}
    public DatabaseConfig(String url, String username, String password, int maxConnections) {}
    public DatabaseConfig(String url, String username, String password, int maxConnections, int timeout) {}
    // ... 更多重载
}

// ✅ 使用建造者模式
DatabaseConfig config = DatabaseConfig.builder()
    .url("jdbc:postgresql://localhost:5432/mydb")
    .username("user")
    .password("password")
    .maxConnections(20)  // 可选
    .timeout(5000)       // 可选
    .enableSsl(true)     // 可选
    .build();
```

**参数类型相同容易混淆**
```java
// ❌ 多个String参数容易传错
public class Rectangle {
    public Rectangle(String width, String height, String color, String borderColor) {
        // 容易把width和height传反
    }
}

// ✅ 使用建造者模式，语义清晰
Rectangle rect = Rectangle.builder()
    .width("100px")
    .height("200px")
    .color("red")
    .borderColor("black")
    .build();
```

**需要参数验证和约束**
```java
// ✅ 建造者模式便于添加验证逻辑
public class EmailBuilder {
    private String to;
    private String subject;
    private String body;
    private List<String> attachments = new ArrayList<>();
    
    public EmailBuilder to(String to) {
        if (to == null || !to.contains("@")) {
            throw new IllegalArgumentException("无效的邮箱地址");
        }
        this.to = to;
        return this;
    }
    
    public EmailBuilder subject(String subject) {
        if (subject == null || subject.trim().isEmpty()) {
            throw new IllegalArgumentException("邮件主题不能为空");
        }
        this.subject = subject;
        return this;
    }
    
    public Email build() {
        // 构建前的最终验证
        if (to == null) throw new IllegalStateException("收件人不能为空");
        if (subject == null) throw new IllegalStateException("主题不能为空");
        
        return new Email(to, subject, body, attachments);
    }
}
```

#### ⚠️ 谨慎考虑的场景

**对象创建逻辑复杂**
```java
// ✅ 复杂的对象创建逻辑
public class ReportBuilder {
    public ReportBuilder withDateRange(LocalDate start, LocalDate end) {
        // 复杂的日期范围验证和处理
        validateDateRange(start, end);
        calculateBusinessDays(start, end);
        return this;
    }
    
    public ReportBuilder withFilters(Consumer<FilterBuilder> filterConfig) {
        // 复杂的过滤器配置
        FilterBuilder filterBuilder = new FilterBuilder();
        filterConfig.accept(filterBuilder);
        this.filters = filterBuilder.build();
        return this;
    }
    
    public Report build() {
        // 复杂的报表生成逻辑
        validateConfiguration();
        processData();
        generateCharts();
        return new Report(this);
    }
}
```

**需要不可变对象**
```java
// ✅ 创建不可变对象
public final class ImmutableUser {
    private final String name;
    private final String email;
    private final List<String> roles;
    
    private ImmutableUser(Builder builder) {
        this.name = builder.name;
        this.email = builder.email;
        this.roles = Collections.unmodifiableList(new ArrayList<>(builder.roles));
    }
    
    public static class Builder {
        private String name;
        private String email;
        private List<String> roles = new ArrayList<>();
        
        public Builder name(String name) {
            this.name = name;
            return this;
        }
        
        public Builder addRole(String role) {
            this.roles.add(role);
            return this;
        }
        
        public ImmutableUser build() {
            return new ImmutableUser(this);
        }
    }
}
```

#### ❌ 不推荐使用的场景

**简单对象（≤3个参数）**
```java
// ❌ 过度设计
public class Point {
    private final int x;
    private final int y;
    
    // 简单构造函数就足够了
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}

// 不需要建造者模式
// Point point = Point.builder().x(10).y(20).build(); // 过度复杂
Point point = new Point(10, 20); // 简单直接
```

**所有参数都是必需的**
```java
// ❌ 如果所有参数都必需，构造函数更合适
public class Triangle {
    public Triangle(Point a, Point b, Point c) {
        // 三个点都是必需的，没有可选参数
    }
}
```

### 2. 🎯 实际项目中的识别方法

#### 代码异味检测

**检查点1：构造函数长度**
```java
// 🚨 发现这样的代码时考虑建造者模式
public OrderRequest(String customerId, String productId, Integer quantity, 
                   BigDecimal price, String couponCode, String deliveryAddress,
                   LocalDateTime deliveryTime, String remark, Boolean isUrgent,
                   String paymentMethod) {
    // 参数过多，考虑建造者模式
}
```

**检查点2：多个重载构造函数**
```java
// 🚨 发现多个重载构造函数时
public class HttpClient {
    public HttpClient(String baseUrl) {}
    public HttpClient(String baseUrl, int timeout) {}
    public HttpClient(String baseUrl, int timeout, Map<String, String> headers) {}
    public HttpClient(String baseUrl, int timeout, Map<String, String> headers, boolean followRedirects) {}
    // 考虑建造者模式
}
```

**检查点3：参数传递错误频发**
```java
// 🚨 经常出现参数传递错误
// 容易把width和height搞混
new Rectangle("200px", "100px", "red", "1px"); // 哪个是宽？哪个是高？

// 建造者模式解决
Rectangle.builder()
    .width("200px")   // 明确语义
    .height("100px")
    .color("red")
    .border("1px")
    .build();
```

#### 业务场景识别

**配置类对象**
```java
// ✅ 配置类通常有很多可选参数
RedisConfig config = RedisConfig.builder()
    .host("localhost")
    .port(6379)
    .password("password")
    .database(0)
    .maxConnections(100)
    .timeout(5000)
    .enableCluster(false)
    .build();
```

**请求/响应对象**
```java
// ✅ API请求对象通常参数较多
ApiRequest request = ApiRequest.builder()
    .url("/api/users")
    .method(HttpMethod.POST)
    .header("Content-Type", "application/json")
    .header("Authorization", "Bearer " + token)
    .body(userJson)
    .timeout(30000)
    .retryCount(3)
    .build();
```

**复杂业务对象**
```java
// ✅ 订单对象包含多个维度的信息
Order order = Order.builder()
    .customerId("C001")
    .addItem("P001", 2, new BigDecimal("99.99"))
    .addItem("P002", 1, new BigDecimal("199.99"))
    .applyCoupon("DISCOUNT10")
    .setDeliveryAddress(address)
    .setDeliveryTime(LocalDateTime.now().plusDays(1))
    .setPaymentMethod(PaymentMethod.CREDIT_CARD)
    .addRemark("请在工作时间配送")
    .build();
```

### 3. 🛠️ 实施建造者模式的步骤

#### 步骤1：识别候选类
```java
// 原始类分析
public class EmailMessage {
    // 8个参数，其中5个可选 → 建造者模式候选
    public EmailMessage(String to, String subject, String body, 
                       String from, List<String> cc, List<String> bcc,
                       Priority priority, List<Attachment> attachments) {
    }
}
```

#### 步骤2：设计Builder接口
```java
public class EmailMessage {
    // 私有构造函数
    private EmailMessage(Builder builder) {
        this.to = builder.to;
        this.subject = builder.subject;
        this.body = builder.body;
        this.from = builder.from;
        this.cc = Collections.unmodifiableList(builder.cc);
        this.bcc = Collections.unmodifiableList(builder.bcc);
        this.priority = builder.priority;
        this.attachments = Collections.unmodifiableList(builder.attachments);
    }
    
    public static Builder builder() {
        return new Builder();
    }
    
    public static class Builder {
        // 必需参数
        private String to;
        private String subject;
        private String body;
        
        // 可选参数及默认值
        private String from = "noreply@company.com";
        private List<String> cc = new ArrayList<>();
        private List<String> bcc = new ArrayList<>();
        private Priority priority = Priority.NORMAL;
        private List<Attachment> attachments = new ArrayList<>();
        
        // 必需参数方法
        public Builder to(String to) {
            this.to = Objects.requireNonNull(to, "收件人不能为空");
            return this;
        }
        
        public Builder subject(String subject) {
            this.subject = Objects.requireNonNull(subject, "主题不能为空");
            return this;
        }
        
        public Builder body(String body) {
            this.body = Objects.requireNonNull(body, "邮件内容不能为空");
            return this;
        }
        
        // 可选参数方法
        public Builder from(String from) {
            this.from = from;
            return this;
        }
        
        public Builder addCc(String cc) {
            this.cc.add(cc);
            return this;
        }
        
        public Builder addBcc(String bcc) {
            this.bcc.add(bcc);
            return this;
        }
        
        public Builder priority(Priority priority) {
            this.priority = priority;
            return this;
        }
        
        public Builder addAttachment(Attachment attachment) {
            this.attachments.add(attachment);
            return this;
        }
        
        // 构建方法
        public EmailMessage build() {
            // 验证必需参数
            if (to == null) throw new IllegalStateException("收件人不能为空");
            if (subject == null) throw new IllegalStateException("主题不能为空");
            if (body == null) throw new IllegalStateException("邮件内容不能为空");
            
            return new EmailMessage(this);
        }
    }
}
```

#### 步骤3：使用示例
```java
// 简单使用
EmailMessage simpleEmail = EmailMessage.builder()
    .to("user@example.com")
    .subject("欢迎注册")
    .body("欢迎您注册我们的服务！")
    .build();

// 复杂使用
EmailMessage complexEmail = EmailMessage.builder()
    .to("user@example.com")
    .subject("月度报告")
    .body("请查看附件中的月度报告")
    .from("report@company.com")
    .addCc("manager@company.com")
    .addCc("team@company.com")
    .priority(Priority.HIGH)
    .addAttachment(new Attachment("report.pdf", reportData))
    .addAttachment(new Attachment("summary.xlsx", summaryData))
    .build();
```

### 4. 🎪 常见的建造者模式变体

#### 流式建造者（Fluent Builder）
```java
public class SqlBuilder {
    private StringBuilder sql = new StringBuilder();
    
    public static SqlBuilder select(String... columns) {
        SqlBuilder builder = new SqlBuilder();
        builder.sql.append("SELECT ").append(String.join(", ", columns));
        return builder;
    }
    
    public SqlBuilder from(String table) {
        sql.append(" FROM ").append(table);
        return this;
    }
    
    public SqlBuilder where(String condition) {
        sql.append(" WHERE ").append(condition);
        return this;
    }
    
    public SqlBuilder orderBy(String column) {
        sql.append(" ORDER BY ").append(column);
        return this;
    }
    
    public String build() {
        return sql.toString();
    }
}

// 使用
String sql = SqlBuilder
    .select("id", "name", "email")
    .from("users")
    .where("age > 18")
    .orderBy("name")
    .build();
```

#### 分步建造者（Step Builder）
```java
// 强制按步骤构建
public class OrderBuilder {
    public static CustomerStep newOrder() {
        return new Steps();
    }
    
    public interface CustomerStep {
        ProductStep customer(String customerId);
    }
    
    public interface ProductStep {
        QuantityStep product(String productId);
    }
    
    public interface QuantityStep {
        BuildStep quantity(int quantity);
    }
    
    public interface BuildStep {
        BuildStep address(String address);
        BuildStep remark(String remark);
        Order build();
    }
    
    private static class Steps implements CustomerStep, ProductStep, QuantityStep, BuildStep {
        private String customerId;
        private String productId;
        private int quantity;
        private String address;
        private String remark;
        
        @Override
        public ProductStep customer(String customerId) {
            this.customerId = customerId;
            return this;
        }
        
        @Override
        public QuantityStep product(String productId) {
            this.productId = productId;
            return this;
        }
        
        @Override
        public BuildStep quantity(int quantity) {
            this.quantity = quantity;
            return this;
        }
        
        @Override
        public BuildStep address(String address) {
            this.address = address;
            return this;
        }
        
        @Override
        public BuildStep remark(String remark) {
            this.remark = remark;
            return this;
        }
        
        @Override
        public Order build() {
            return new Order(customerId, productId, quantity, address, remark);
        }
    }
}

// 使用 - 强制按顺序
Order order = OrderBuilder.newOrder()
    .customer("C001")      // 必须先设置客户
    .product("P001")       // 然后设置产品
    .quantity(2)           // 然后设置数量
    .address("北京市朝阳区")  // 可选：设置地址
    .remark("加急处理")     // 可选：设置备注
    .build();
```

### 5. 📋 建造者模式检查清单

#### ✅ 使用建造者模式的检查清单

- [ ] **参数数量**：构造函数参数 ≥ 4个
- [ ] **可选参数**：存在多个可选参数
- [ ] **参数类型**：多个相同类型参数容易混淆
- [ ] **重载构造函数**：需要多个重载构造函数
- [ ] **参数验证**：需要复杂的参数验证逻辑
- [ ] **对象复杂性**：对象创建逻辑复杂
- [ ] **不可变性**：需要创建不可变对象
- [ ] **可读性**：提高代码可读性和维护性

#### ❌ 不使用建造者模式的检查清单

- [ ] **简单对象**：参数 ≤ 3个且都是必需的
- [ ] **性能敏感**：对象创建频率极高且性能敏感
- [ ] **团队不熟悉**：团队对建造者模式不熟悉
- [ ] **过度设计**：简单场景不需要复杂的设计模式

### 6. 🎯 最佳实践建议

#### ✅ 推荐做法

1. **明确必需参数和可选参数**
2. **提供合理的默认值**
3. **添加参数验证**
4. **保持方法链的流畅性**
5. **使用静态工厂方法创建Builder**
6. **考虑线程安全性**
7. **提供清晰的文档和示例**

#### ❌ 避免的做法

1. **为简单对象使用建造者模式**
2. **忽略参数验证**
3. **Builder类过于复杂**
4. **缺乏明确的构建步骤**
5. **忽略性能影响**

---

## 📝 快速决策指南

### 🚦 红绿灯决策法

🔴 **红灯（不推荐）**
- 参数 ≤ 3个
- 所有参数都必需
- 对象创建频率极高
- 简单的数据传输对象

🟡 **黄灯（谨慎考虑）**
- 参数 = 4个
- 有1-2个可选参数
- 对象创建逻辑中等复杂
- 团队对模式不熟悉

🟢 **绿灯（强烈推荐）**
- 参数 ≥ 5个
- 多个可选参数
- 需要参数验证
- 相同类型参数容易混淆
- 需要不可变对象
- 对象创建逻辑复杂

### 📊 评分系统

给以下因素打分（1-5分），总分 ≥ 15分建议使用建造者模式：

- 参数数量（1分：≤3个，3分：4-5个，5分：≥6个）
- 可选参数比例（1分：0%，3分：30-50%，5分：≥60%）
- 参数类型复杂度（1分：简单，3分：中等，5分：复杂）
- 验证需求（1分：无，3分：简单，5分：复杂）
- 使用频率（1分：极高，3分：中等，5分：较低）

记住：**建造者模式是为了解决复杂对象创建问题，不要为了使用模式而使用模式！**